<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2025/11/12/1/"/>
    <url>/2025/11/12/1/</url>
    
    <content type="html"><![CDATA[<h1 id="使二进制字符串字符交替的最少反转次数"><a href="https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/">1888. 使二进制字符串字符交替的最少反转次数</a></h1><p>给你一个二进制字符串 <code>s</code> 。你可以按任意顺序执行以下两种操作任意次：</p><ul><li><strong>类型 1 ：删除</strong> 字符串 <code>s</code> 的第一个字符并将它 <strong>添加</strong> 到字符串结尾。</li><li><strong>类型 2 ：选择</strong> 字符串 <code>s</code> 中任意一个字符并将该字符 <strong>反转</strong> ，也就是如果值为 <code>'0'</code> ，则反转得到 <code>'1'</code> ，反之亦然。</li></ul><p>请你返回使 <code>s</code> 变成 <strong>交替</strong> 字符串的前提下， <strong>类型 2</strong> 的 <strong>最少</strong> 操作次数 。</p><p>我们称一个字符串是 <strong>交替</strong> 的，需要满足任意相邻字符都不同。</p><ul><li><p>比方说，字符串 <code>"010"</code> 和 <code>"1010"</code> 都是交替的，但是字符串 <code>"0100"</code> 不是</p><h2 id="核心难点-to-计算反转次数">核心难点 <span class="math inline">→</span> 计算反转次数</h2></li><li><p>方法一：暴力枚举</p><p>对于每个窗口，枚举所需的次数，<strong>时间复杂度</strong>为<span class="math inline"><em>O</em>(2 ⋅ <em>n</em><sup>2</sup>)</span></p></li><li><p>方法二：找规律</p><p>注意到，如果要满足题目条件，<strong>窗口内必须满足<span class="math inline">0101⋯</span>或者<span class="math inline">1010⋯</span>形式</strong></p><p><strong>满足$0101<span class="math inline"><em>则</em></span> t[i]= i mod 2$</strong></p><p><strong>满足$1010<span class="math inline"><em>则</em></span>t[i]i mod 2$</strong></p><p>我们将<span class="math inline"><em>t</em>[<em>i</em>] ≠ <em>i</em> <em>m</em><em>o</em><em>d</em> 2</span> 的<strong>数量</strong>设为<strong><code>cnt</code></strong></p><p>当窗口<strong>左端点</strong>的下标为<strong>偶数</strong>时，<strong><code>cnt</code></strong>为满足<span class="math inline">1010⋯</span>的<strong>操作类型2的总次数</strong>，<strong><code>n - cnt</code></strong>则为满足<span class="math inline">0101⋯</span>的<strong>操作类型2的总次数</strong>，当窗口<strong>左端点</strong>的下标为<strong>奇数</strong>时则相反</p><p>对于每个窗口，都可以改为<span class="math inline">1010⋯</span>或者<span class="math inline">0101⋯</span>形式，所以，每个窗口的操作次数应为</p><p>​ <strong><span class="math inline">min (<em>c</em><em>n</em><em>t</em>, <em>n</em> − <em>c</em><em>n</em><em>t</em>)</span></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-keyword">if</span> (s[i % n] % <span class="hljs-number">2</span> != i % <span class="hljs-number">2</span>) cnt++;<br>    <span class="hljs-type">int</span> left = i - n + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    ans = <span class="hljs-built_in">min</span>(&#123;ans, cnt, n - cnt&#125;);<br>    <span class="hljs-keyword">if</span> (s[left] % <span class="hljs-number">2</span> != i % <span class="hljs-number">2</span>) cnt--;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr /><h1 id="字符串的排列"><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></h1><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的 排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p><ul><li><p>解决方法：</p><p>对于s1，用<code>cnt[]</code>来记录每个字母出现的次数，用<code>less</code>来记录s1中字母有多少种</p><p>对于每个窗口，<span class="math inline"><em>c</em><em>n</em><em>t</em>[<em>s</em>2[<em>i</em>]]</span>如果<strong>归零</strong>，则<code>less--</code>，如果该窗口能使<code>less == 0</code>，则符合条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>], less; <span class="hljs-comment">// cnt[],less初始化如上文</span><br><span class="hljs-type">int</span> n = s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(), m = s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">int</span> in = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    cnt[in]--;<br>    <span class="hljs-keyword">if</span> (cnt[in] == <span class="hljs-number">0</span>) less--;<br>    <span class="hljs-type">int</span> left = i - m + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (less == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> out = s[left] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (cnt[out] == <span class="hljs-number">0</span>) less++;<br>    cnt[out]++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li></ul><hr /><h1 id="串联所有单词的子串"><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></h1><p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p><p><code>s</code> 中的 <strong>串联子串</strong> 是指一个包含 <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = ["ab","cd","ef"]</code>， 那么 <code>"abcdef"</code>， <code>"abefcd"</code>，<code>"cdabef"</code>， <code>"cdefab"</code>，<code>"efabcd"</code>， 和 <code>"efcdab"</code> 都是串联子串。 <code>"acdbef"</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p><h2 id="my-solution-oncdot-m">My Solution <span class="math inline"><em>O</em>(<em>n</em> ⋅ <em>m</em>)</span></h2><ul><li><p>核心思想，哈希表储存每个<strong><code>word</code></strong>的出现次数，用<strong><code>less</code></strong>储存不同的<strong><code>word</code></strong>的总数，定长滑动窗口来获得答案</p><p><span class="math inline"><em>n</em></span> 代表<span class="math inline"><em>s</em>.<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em></span>，<span class="math inline"><em>m</em></span>表示<code>words</code>内每个<span class="math inline"><em>w</em><em>o</em><em>r</em><em>d</em></span>的长度，_m表示<code>words</code>的长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<span class="hljs-comment">//遍历整个s字符串</span><br>    <span class="hljs-type">int</span> i = i - m + <span class="hljs-number">1</span> + j;<br>    <span class="hljs-keyword">for</span> (; i &lt; n; i += m)&#123;<span class="hljs-comment">//步进每个单词</span><br>        string segment = s.<span class="hljs-built_in">substr</span>(i - m + <span class="hljs-number">1</span>, m);<br>        cnt[segment]--;<br>        <span class="hljs-keyword">if</span> (cnt[segment] == <span class="hljs-number">0</span>) less--;<br>        <span class="hljs-type">int</span> left = i - m * _m + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (less == <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(left);<br>        segment = s.<span class="hljs-built_in">substr</span>(left, m);<br>        <span class="hljs-keyword">if</span> (cnt[segment] == <span class="hljs-number">0</span>) less++;<br>        cnt[segment]++;<br>    &#125;<br>    <span class="hljs-comment">//考虑到滑动窗口结束时，仍未完全回溯</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = i - m * _m + <span class="hljs-number">1</span>; left &lt;= n - m; left += m)&#123;<br>        <span class="hljs-comment">//left &lt;= n - m 从尾部取m个字符时避免越界</span><br>        string segment = s.<span class="hljs-built_in">substr</span>(left, m);<br>        <span class="hljs-keyword">if</span> (cnt[segment] == <span class="hljs-number">0</span>) less++;<br>        cnt[segment]++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr /><h1 id="子串能表示从-1-到-n-数字的二进制串"><a href="https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/">1016. 子串能表示从 1 到 N 数字的二进制串</a></h1><p>给定一个二进制字符串 <code>s</code> 和一个正整数 <code>n</code>，如果对于 <code>[1, n]</code> 范围内的每个整数，<em>其二进制表示都是 s 的 <strong>子字符串</strong> ，就返回 true，否则返回 false</em> 。</p><p><strong>子字符串</strong> 是字符串中连续的字符序列。</p><p><span class="math inline"><em>O</em>(<em>m</em>)</span>算法：</p><p>设 <span class="math inline"><em>n</em></span> 的二进制数(<code>bit_width</code>)为 <span class="math inline"><em>k</em> + 1</span>：</p><p>单看闭区间 <span class="math inline">[4, 7]</span> ，有 4 个互不相同的整数，它们的二进制数均为 3，如果要让字符串 <span class="math inline"><em>s</em></span> 包含这 4 个数，<span class="math inline"><em>s</em></span> 中至少要有 4 个长为 3 的互不相同子串，则应满足 <span class="math inline"><em>m</em> ≥ 3 + (4 − 1) = 6</span> ，否则返回<strong><code>false</code></strong></p><ul><li>区间 <span class="math inline">[2<sup><em>k</em></sup>, <em>n</em>]</span> 内<strong>每个数</strong>的二进制数为 <span class="math inline"><em>k</em> + 1</span> ，一共有 <span class="math inline"><em>n</em> − 2<sup><em>k</em></sup> + 1</span>个，所以应满足<span class="math inline"><em>m</em> ≥ <em>k</em> + 1 + (<em>n</em> − 2<sup><em>k</em></sup> + 1 − 1) = <em>k</em> + 1 + <em>n</em> − 2<sup><em>k</em></sup></span></li><li>区间 <span class="math inline">[2<sup><em>k</em> − 1</sup>, 2<sup><em>k</em></sup> − 1]</span> 内<strong>每个数</strong>的二进制数为 <span class="math inline"><em>k</em></span> ，一共有 <span class="math inline">2<sup><em>k</em> − 1</sup></span> 个，所以应满足 <span class="math inline"><em>m</em> ≥ <em>k</em> + 2<sup><em>k</em> − 1</sup> − 1</span></li><li>注意，当 <span class="math inline"><em>n</em> = 1</span> 时，<span class="math inline"><em>k</em> = 0</span> ，此时需要特判，检查 <span class="math inline"><em>s</em></span> 中是否包含 1</li></ul><p>注意到 <span class="math inline">[2<sup><em>k</em> − 1</sup>, 2<sup><em>k</em></sup>]</span> 区间内的所有数字都右移 1 位，便能得到 <span class="math inline">[2<sup><em>k</em> − 2</sup>, 2<sup><em>k</em> − 1</sup> − 1]</span> 内的所有数字，如果 <span class="math inline"><em>s</em></span> 包含 <span class="math inline">[2<sup><em>k</em> − 1</sup>, 2<sup><em>k</em></sup>]</span> 内的所有二进制数，则必能得到 <span class="math inline">[2<sup><em>k</em> − 2</sup>, 2<sup><em>k</em> − 1</sup> − 1]</span> 内的所有二进制数，所以仅需考虑 $[2<sup>{k-1},2</sup>k] $ 即可，综上，只需考虑 <span class="math inline"><em>s</em></span> 内是否包含 <span class="math inline">[2<sup><em>k</em> − 1</sup>, 2<sup><em>k</em></sup> − 1]</span> 和 <span class="math inline">[2<sup><em>k</em></sup>, <em>n</em>]</span> 的所有二进制数即可</p><p>因此，如果 <span class="math display"><em>m</em> &lt; <em>m</em><em>a</em><em>x</em>(<em>k</em> + 1 + <em>n</em> − 2<sup><em>k</em></sup>, <em>k</em> + 2<sup><em>k</em></sup> − 1)</span> 可以直接返回<strong><code>false</code></strong></p><p>进一步的， <span class="math inline">[2<sup><em>k</em></sup>, <em>n</em>]</span> 能够得到 <span class="math inline">[2<sup><em>k</em> − 1</sup>, ⌊<em>n</em>/2⌋]</span> ，所以对于 <span class="math inline">[2<sup><em>k</em> − 1</sup>, 2<sup><em>k</em></sup> − 1]</span> 来说，只需从 <span class="math inline">⌊<em>n</em>/2⌋ + 1</span> 来考虑即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">queryString</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">bit_width</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n) - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;1&#x27;</span>) != string::npos;<br>        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span> + k + n - (<span class="hljs-number">1</span> &lt;&lt; k), k + (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper) -&gt; <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">if</span> (lower &gt; upper) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            unordered_set&lt;<span class="hljs-type">int</span>&gt; seen;<br>            <span class="hljs-type">int</span> mask = (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> x = <span class="hljs-built_in">stoi</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>), <span class="hljs-literal">nullptr</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">//将二进制转换为十进制</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>                x = ((x &amp; mask) &lt;&lt; <span class="hljs-number">1</span>) | (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//实现出-&gt;入窗口</span><br>                <span class="hljs-keyword">if</span> (lower &lt;= x &amp;&amp; x &lt;= upper)<br>                    seen.<span class="hljs-built_in">insert</span>(x);<br>            &#125;<br>            <span class="hljs-keyword">return</span> seen.<span class="hljs-built_in">size</span>() == upper - lower + <span class="hljs-number">1</span>;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(k, n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, (<span class="hljs-number">1</span> &lt;&lt; k) - <span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">check</span>(k + <span class="hljs-number">1</span>, <span class="hljs-number">1</span> &lt;&lt; k, n);<br>    &#125;<br></code></pre></td></tr></table></figure><hr /><h1 id="找出最长等值子数组"><a href="https://leetcode.cn/problems/find-the-longest-equal-subarray/">2831. 找出最长等值子数组</a></h1><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>如果子数组中所有元素都相等，则认为子数组是一个 <strong>等值子数组</strong> 。注意，空数组是 <strong>等值子数组</strong> 。</p><p>从 <code>nums</code> 中删除最多 <code>k</code> 个元素后，返回可能的最长等值子数组的长度。</p><p><strong>子数组</strong> 是数组中一个连续且可能为空的元素序列。</p><ul><li><p><strong>核心</strong><span class="math inline">→</span><strong>分组</strong></p><p>我们可以枚举每位数字在数组的下标，比较两个下标间应该删除元素的数量与 <span class="math inline"><em>k</em></span> 的大小来决定是否移窗口</p><p>使用 <code>vector&lt;vector&lt;int&gt;&gt; pos_lists</code> 来记录</p><p><strong>最关键步骤：</strong><code>pos_lists[x].push_back(i - pos_lists[x].size());</code></p><p>假设数组为：<code>[1, 2, 1, 3, 1, 4, 1]</code>，我们关注数值 <code>1</code></p><p>数值1的位置：索引 <code>0, 2, 4, 6</code></p><p><strong>传统思路：</strong></p><ul><li>保留位置0和2：需要删除索引1处的元素(2) → 删除1个</li><li>保留位置0,2,4：需要删除索引1(2)和索引3(3) → 删除2个</li><li>保留位置0,2,4,6：需要删除索引1(2)、索引3(3)、索引5(4) → 删除3个</li></ul><p><strong>转换思路：</strong> 对于第 <span class="math inline"><em>j</em></span> 个1（从0开始计数），计算：<code>原始位置 - j</code></p><ul><li><p>第0个1（位置0）：<code>0 - 0 = 0</code></p></li><li><p>第1个1（位置2）：<code>2 - 1 = 1</code></p></li><li><p>第2个1（位置4）：<code>4 - 2 = 2</code></p></li><li><p>第3个1（位置6）：<code>6 - 3 = 3</code></p><p>得到转换后位置：<code>[0, 1, 2, 3]</code>，可以发现，得到了前 <span class="math inline"><em>j</em></span> 个 1 要删除的数</p></li></ul><p>对于 <span class="math inline"><em>l</em><em>e</em><em>f</em><em>t</em></span> 处和 <span class="math inline"><em>r</em><em>i</em><em>g</em><em>h</em><em>t</em></span> 处的数字 <span class="math inline"><em>x</em></span>， 所需要删除的数量变为 <span class="math inline"><em>p</em><em>o</em><em>s</em>[<em>r</em><em>i</em><em>g</em><em>h</em><em>t</em>] − <em>p</em><em>o</em><em>s</em>[<em>l</em><em>e</em><em>f</em><em>t</em>]</span></p><p>如果 <span class="math inline"><em>p</em><em>o</em><em>s</em>[<em>r</em><em>i</em><em>g</em><em>h</em><em>t</em>] − <em>p</em><em>o</em><em>s</em>[<em>l</em><em>e</em><em>f</em><em>t</em>] &gt; <em>k</em></span> 则缩小窗口，最长的答案应为 <span class="math inline"><em>m</em><em>a</em><em>x</em>(<em>a</em><em>n</em><em>s</em>, <em>r</em><em>i</em><em>g</em><em>h</em><em>t</em> − <em>l</em><em>e</em><em>f</em><em>t</em> + 1)</span></p><hr /><h1 id="统计好子数组的数目"><a href="https://leetcode.cn/problems/count-the-number-of-good-subarrays/">2537. 统计好子数组的数目</a></h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <code>nums</code> 中 <strong>好</strong> 子数组的数目。</p><p>一个子数组 <code>arr</code> 如果有 <strong>至少</strong> <code>k</code> 对下标 <code>(i, j)</code> 满足 <code>i &lt; j</code> 且 <code>arr[i] == arr[j]</code> ，那么称它是一个 <strong>好</strong> 子数组。</p><p><strong>子数组</strong> 是原数组中一段连续 <strong>非空</strong> 的元素序列。</p><ul><li><p>核心思想，统计窗口内每个 <span class="math inline"><em>x</em></span> 出现的个数，记为 <span class="math inline"><em>c</em><em>n</em><em>t</em>[<em>x</em>]</span></p><p>考虑维护窗口，当进入的数为 <span class="math inline"><em>x</em></span> 时，窗口内便会有 <span class="math inline"><em>c</em><em>n</em><em>t</em>[<em>x</em>]</span> 个数与之相匹配，同理，当 <span class="math inline"><em>n</em><em>u</em><em>m</em><em>s</em>[<em>l</em><em>e</em><em>f</em><em>t</em>]</span> 离开窗口时，窗口内便有 <span class="math inline"><em>c</em><em>n</em><em>t</em>[<em>x</em>] − 1</span> 个数失去匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : nums)&#123;<br>            cnt[x]++;<br>            sum += cnt[x] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (sum &gt;= k)&#123;<br>                sum -= cnt[nums[left++]] - <span class="hljs-number">1</span>;<br>            &#125;<br>            ans += left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>C++</tag>
      
      <tag>基础算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Test</title>
    <link href="/2025/11/12/Test/"/>
    <url>/2025/11/12/Test/</url>
    
    <content type="html"><![CDATA[<h1 id="这只是一个测试"><a href="#这只是一个测试" class="headerlink" title="这只是一个测试"></a>这只是一个测试</h1><h2 id="哈基米"><a href="#哈基米" class="headerlink" title="哈基米"></a>哈基米</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-f5563d79" role="button" aria-expanded="false" aria-controls="collapse-f5563d79">        <div class="fold-arrow">▶</div>title      </div>      <div class="fold-collapse collapse" id="collapse-f5563d79">        <div class="fold-content">          <p>$ \frac{a}{b} + \frac{c}{d} &#x3D; 114514 $</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std:: cout &lt;&lt; <span class="hljs-string">&quot;Hachimi&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
