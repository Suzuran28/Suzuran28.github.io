<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2025/11/12/1/"/>
    <url>/2025/11/12/1/</url>
    
    <content type="html"><![CDATA[<h1 id="1888-使二进制字符串字符交替的最少反转次数"><a href="#1888-使二进制字符串字符交替的最少反转次数" class="headerlink" title="1888. 使二进制字符串字符交替的最少反转次数"></a><a href="https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/">1888. 使二进制字符串字符交替的最少反转次数</a></h1><p>给你一个二进制字符串 <code>s</code> 。你可以按任意顺序执行以下两种操作任意次：</p><ul><li><strong>类型 1 ：删除</strong> 字符串 <code>s</code> 的第一个字符并将它 <strong>添加</strong> 到字符串结尾。</li><li><strong>类型 2 ：选择</strong> 字符串 <code>s</code> 中任意一个字符并将该字符 <strong>反转</strong> ，也就是如果值为 <code>&#39;0&#39;</code> ，则反转得到 <code>&#39;1&#39;</code> ，反之亦然。</li></ul><p>请你返回使 <code>s</code> 变成 <strong>交替</strong> 字符串的前提下， <strong>类型 2</strong> 的 <strong>最少</strong> 操作次数 。</p><p>我们称一个字符串是 <strong>交替</strong> 的，需要满足任意相邻字符都不同。</p><ul><li><p>比方说，字符串 <code>&quot;010&quot;</code> 和 <code>&quot;1010&quot;</code> 都是交替的，但是字符串 <code>&quot;0100&quot;</code> 不是</p><h2 id="核心难点-to-计算反转次数"><a href="#核心难点-to-计算反转次数" class="headerlink" title="核心难点 $$\to$$ 计算反转次数"></a>核心难点 $$\to$$ 计算反转次数</h2></li><li><p>方法一：暴力枚举</p><p>对于每个窗口，枚举所需的次数，<strong>时间复杂度</strong>为$$O(2\cdot{n^2})$$</p></li><li><p>方法二：找规律</p><p>注意到，如果要满足题目条件，<strong>窗口内必须满足$$0101\cdots$$或者$$1010\cdots$$形式</strong></p><p><strong>满足$$0101\cdots $$则$$ t[i]&#x3D; i\ mod\ 2$$</strong></p><p><strong>满足$$1010\cdots $$则$$t[i]\neq i\ mod\ 2$$</strong></p><p>我们将$$t[i] \neq i\ mod\ 2$$ 的<strong>数量</strong>设为**<code>cnt</code>**</p><p>当窗口<strong>左端点</strong>的下标为<strong>偶数</strong>时，<strong><code>cnt</code><strong>为满足$$1010\cdots$$的</strong>操作类型2的总次数</strong>，<strong><code>n - cnt</code><strong>则为满足$$0101\cdots$$的</strong>操作类型2的总次数</strong>，当窗口<strong>左端点</strong>的下标为<strong>奇数</strong>时则相反</p><p>对于每个窗口，都可以改为$$1010\cdots$$或者$$0101\cdots$$形式，所以，每个窗口的操作次数应为</p><p>​                                                            <strong>$$\min(cnt, n-cnt)$$</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-keyword">if</span> (s[i % n] % <span class="hljs-number">2</span> != i % <span class="hljs-number">2</span>) cnt++;<br>    <span class="hljs-type">int</span> left = i - n + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    ans = <span class="hljs-built_in">min</span>(&#123;ans, cnt, n - cnt&#125;);<br>    <span class="hljs-keyword">if</span> (s[left] % <span class="hljs-number">2</span> != i % <span class="hljs-number">2</span>) cnt--;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h1 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></h1><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的 排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p><ul><li><p>解决方法：</p><p>对于s1，用<code>cnt[]</code>来记录每个字母出现的次数，用<code>less</code>来记录s1中字母有多少种</p><p>对于每个窗口，$$cnt[s2[i]]$$如果<strong>归零</strong>，则<code>less--</code>，如果该窗口能使<code>less == 0</code>，则符合条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>], less; <span class="hljs-comment">// cnt[],less初始化如上文</span><br><span class="hljs-type">int</span> n = s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(), m = s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">int</span> in = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    cnt[in]--;<br>    <span class="hljs-keyword">if</span> (cnt[in] == <span class="hljs-number">0</span>) less--;<br>    <span class="hljs-type">int</span> left = i - m + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (less == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> out = s[left] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (cnt[out] == <span class="hljs-number">0</span>) less++;<br>    cnt[out]++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li></ul><hr><h1 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></h1><p>给定一个字符串 <code>s</code> 和一个字符串数组 <code>words</code><strong>。</strong> <code>words</code> 中所有字符串 <strong>长度相同</strong>。</p><p> <code>s</code> 中的 <strong>串联子串</strong> 是指一个包含  <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p><ul><li>例如，如果 <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 <code>&quot;abcdef&quot;</code>， <code>&quot;abefcd&quot;</code>，<code>&quot;cdabef&quot;</code>， <code>&quot;cdefab&quot;</code>，<code>&quot;efabcd&quot;</code>， 和 <code>&quot;efcdab&quot;</code> 都是串联子串。 <code>&quot;acdbef&quot;</code> 不是串联子串，因为他不是任何 <code>words</code> 排列的连接。</li></ul><p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p><h2 id="My-Solution-O-n-cdot-m"><a href="#My-Solution-O-n-cdot-m" class="headerlink" title="My Solution $$O(n\cdot m)$$"></a>My Solution $$O(n\cdot m)$$</h2><ul><li><p>核心思想，哈希表储存每个**<code>word</code><strong>的出现次数，用</strong><code>less</code><strong>储存不同的</strong><code>word</code>**的总数，定长滑动窗口来获得答案</p><p>$n$ 代表$s.length$，$m$表示<code>words</code>内每个$word$的长度，_m表示<code>words</code>的长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<span class="hljs-comment">//遍历整个s字符串</span><br>    <span class="hljs-type">int</span> i = i - m + <span class="hljs-number">1</span> + j;<br>    <span class="hljs-keyword">for</span> (; i &lt; n; i += m)&#123;<span class="hljs-comment">//步进每个单词</span><br>        string segment = s.<span class="hljs-built_in">substr</span>(i - m + <span class="hljs-number">1</span>, m);<br>        cnt[segment]--;<br>        <span class="hljs-keyword">if</span> (cnt[segment] == <span class="hljs-number">0</span>) less--;<br>        <span class="hljs-type">int</span> left = i - m * _m + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (less == <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(left);<br>        segment = s.<span class="hljs-built_in">substr</span>(left, m);<br>        <span class="hljs-keyword">if</span> (cnt[segment] == <span class="hljs-number">0</span>) less++;<br>        cnt[segment]++;<br>    &#125;<br>    <span class="hljs-comment">//考虑到滑动窗口结束时，仍未完全回溯</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = i - m * _m + <span class="hljs-number">1</span>; left &lt;= n - m; left += m)&#123;<br>        <span class="hljs-comment">//left &lt;= n - m 从尾部取m个字符时避免越界</span><br>        string segment = s.<span class="hljs-built_in">substr</span>(left, m);<br>        <span class="hljs-keyword">if</span> (cnt[segment] == <span class="hljs-number">0</span>) less++;<br>        cnt[segment]++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h1 id="1016-子串能表示从-1-到-N-数字的二进制串"><a href="#1016-子串能表示从-1-到-N-数字的二进制串" class="headerlink" title="1016. 子串能表示从 1 到 N 数字的二进制串"></a><a href="https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/">1016. 子串能表示从 1 到 N 数字的二进制串</a></h1><p>给定一个二进制字符串 <code>s</code> 和一个正整数 <code>n</code>，如果对于 <code>[1, n]</code> 范围内的每个整数，<em>其二进制表示都是 s 的 <strong>子字符串</strong> ，就返回 true，否则返回 false</em> 。</p><p><strong>子字符串</strong> 是字符串中连续的字符序列。</p><p>$O(m)$算法：</p><p>设 $n$ 的二进制数(<code>bit_width</code>)为 $k + 1$：</p><p>单看闭区间 $[4,7]$ ，有 4 个互不相同的整数，它们的二进制数均为 3，如果要让字符串 $s$ 包含这 4 个数，$s$ 中至少要有 4 个长为 3 的互不相同子串，则应满足 $m\ge 3 +(4 - 1)&#x3D;6$ ，否则返回**<code>false</code>**</p><ul><li>区间 $[2^k,n]$ 内<strong>每个数</strong>的二进制数为 $k+1$ ，一共有 $n - 2^k + 1$个，所以应满足$m\ge k+1+(n-2^k+1-1)&#x3D;k+1+n-2^k$</li><li>区间 $[2^{k-1},2^k-1]$ 内<strong>每个数</strong>的二进制数为 $k$ ，一共有 $2^{k-1}$ 个，所以应满足 $m\ge k + 2^{k-1} -1$</li><li>注意，当 $n&#x3D;1$ 时，$k&#x3D;0$ ，此时需要特判，检查 $s$ 中是否包含 1</li></ul><p>注意到 $[2^{k-1},2^{k}]$ 区间内的所有数字都右移 1 位，便能得到 $[2^{k-2},2^{k-1} -1]$ 内的所有数字，如果 $s$ 包含 $[2^{k-1},2^k]$ 内的所有二进制数，则必能得到 $[2^{k-2},2^{k-1}-1]$ 内的所有二进制数，所以仅需考虑 $[2^{k-1},2^k] $ 即可，综上，只需考虑 $s$ 内是否包含 $[2^{k-1},2^{k}-1]$ 和 $[2^k,n]$ 的所有二进制数即可</p><p>因此，如果<br>$$<br>m&lt;max({k+1+n-2^k},{k+2^k-1})<br>$$<br>可以直接返回**<code>false</code>**</p><p>进一步的， $[2^k,n]$ 能够得到 $[2^{k-1}, \lfloor n&#x2F;2\rfloor]$ ，所以对于 $[2^{k-1},2^{k}-1]$ 来说，只需从 $\lfloor n&#x2F;2\rfloor +1$ 来考虑即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">queryString</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">bit_width</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n) - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;1&#x27;</span>) != string::npos;<br>        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span> + k + n - (<span class="hljs-number">1</span> &lt;&lt; k), k + (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper) -&gt; <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">if</span> (lower &gt; upper) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            unordered_set&lt;<span class="hljs-type">int</span>&gt; seen;<br>            <span class="hljs-type">int</span> mask = (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> x = <span class="hljs-built_in">stoi</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>), <span class="hljs-literal">nullptr</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">//将二进制转换为十进制</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>                x = ((x &amp; mask) &lt;&lt; <span class="hljs-number">1</span>) | (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//实现出-&gt;入窗口</span><br>                <span class="hljs-keyword">if</span> (lower &lt;= x &amp;&amp; x &lt;= upper)<br>                    seen.<span class="hljs-built_in">insert</span>(x);<br>            &#125;<br>            <span class="hljs-keyword">return</span> seen.<span class="hljs-built_in">size</span>() == upper - lower + <span class="hljs-number">1</span>;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(k, n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, (<span class="hljs-number">1</span> &lt;&lt; k) - <span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">check</span>(k + <span class="hljs-number">1</span>, <span class="hljs-number">1</span> &lt;&lt; k, n);<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h1 id="2831-找出最长等值子数组"><a href="#2831-找出最长等值子数组" class="headerlink" title="2831. 找出最长等值子数组"></a><a href="https://leetcode.cn/problems/find-the-longest-equal-subarray/">2831. 找出最长等值子数组</a></h1><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>如果子数组中所有元素都相等，则认为子数组是一个 <strong>等值子数组</strong> 。注意，空数组是 <strong>等值子数组</strong> 。</p><p>从 <code>nums</code> 中删除最多 <code>k</code> 个元素后，返回可能的最长等值子数组的长度。</p><p><strong>子数组</strong> 是数组中一个连续且可能为空的元素序列。</p><ul><li><p><strong>核心</strong>$\to$<strong>分组</strong></p><p>我们可以枚举每位数字在数组的下标，比较两个下标间应该删除元素的数量与 $k$ 的大小来决定是否移窗口</p><p>使用 <code>vector&lt;vector&lt;int&gt;&gt; pos_lists</code> 来记录</p><p><strong>最关键步骤：</strong><code>pos_lists[x].push_back(i - pos_lists[x].size());</code></p><p>假设数组为：<code>[1, 2, 1, 3, 1, 4, 1]</code>，我们关注数值 <code>1</code></p><p>数值1的位置：索引 <code>0, 2, 4, 6</code></p><p><strong>传统思路：</strong></p><ul><li>保留位置0和2：需要删除索引1处的元素(2) → 删除1个</li><li>保留位置0,2,4：需要删除索引1(2)和索引3(3) → 删除2个</li><li>保留位置0,2,4,6：需要删除索引1(2)、索引3(3)、索引5(4) → 删除3个</li></ul><p><strong>转换思路：</strong><br>  对于第 $j$ 个1（从0开始计数），计算：<code>原始位置 - j</code></p><ul><li><p>第0个1（位置0）：<code>0 - 0 = 0</code></p></li><li><p>第1个1（位置2）：<code>2 - 1 = 1</code></p></li><li><p>第2个1（位置4）：<code>4 - 2 = 2</code></p></li><li><p>第3个1（位置6）：<code>6 - 3 = 3</code></p><p>得到转换后位置：<code>[0, 1, 2, 3]</code>，可以发现，得到了前 $j$ 个 1 要删除的数</p></li></ul><p>对于 $left$ 处和 $right$ 处的数字 $x$， 所需要删除的数量变为 $pos[right] - pos[left]$</p><p>如果 $pos[right] - pos[left] &gt; k$ 则缩小窗口，最长的答案应为 $max(ans, right - left +1)$</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
      <tag>C++</tag>
      
      <tag>基础算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Test</title>
    <link href="/2025/11/12/Test/"/>
    <url>/2025/11/12/Test/</url>
    
    <content type="html"><![CDATA[<h1 id="这只是一个测试"><a href="#这只是一个测试" class="headerlink" title="这只是一个测试"></a>这只是一个测试</h1><h2 id="哈基米"><a href="#哈基米" class="headerlink" title="哈基米"></a>哈基米</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-f5563d79" role="button" aria-expanded="false" aria-controls="collapse-f5563d79">        <div class="fold-arrow">▶</div>title      </div>      <div class="fold-collapse collapse" id="collapse-f5563d79">        <div class="fold-content">          <p>$ \frac{a}{b} + \frac{c}{d} &#x3D; 114514 $</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std:: cout &lt;&lt; <span class="hljs-string">&quot;Hachimi&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
